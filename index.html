<!DOCTYPE html>
<html>
<body>
<h1>Git101 Blog Posts</h1>
  <h2>What Software Engineering means to me</h2>
    <p> Software engineering is the development, implementation, and maintenance of code that allows users to perform specific tasks. Usually includes development of a user friendly interface to operate the program. Everything detail that makes the program operate correctly is developed through the process of software engineering </p>
   <br>
  <h2>Post Chapter 1 reading </h2>
  <p> - put in extra effort to make your code worth it <br>
      - dont make excuses, find solutions <br>
      - decide the best way to present ideas and codes <br>
      - always be trying to learn more directly related and indirectly related <br>
      - dont let little problems build up <br>
      - be willing to initiate and respond to communication <br>
      this chapter was basically life lessons for a professional programmer. It had a lot of good information
      about problems a professional programmer might face and how to handle them. </p>
      <br>
  <h2>Chapter 2</h2>
    <p> It seems that good programming technique is to avoid repetition as much as possible, even if it is inadvertant there appears to be no other way around it, it is usually better to not repeat knowledge. A good tip is to take the time now to prevent problems later. ORTHAGONAL - changing one method does not affect another.AKA ability to change interface without affecting the database. Using multiple languages on one project isnt bad and can make it easier in the long run. "tracer bullets" can help when you're dealing with a lot of unknowns or shooting in the dark. Prototypes are sometimes a better option than "tracer bullets". Estimating accurately is important for understanding when a project will be done and allows for realistic expectations. 
      <br>
      This chapter provides a lot of hints and tips for working on large scale projects and how to keep the code tighty and make it run smoothly for everyone involved on the project. It is a good guideline for such projects.
      <p>
        <br>
  <h2>Chapter 3</h2>
    <p> Originally I assumed a programmer having a good toolbox was in reference to them being familiar with several languages and being familiar enough with them to work on projects based in that programming language. Now I see that there is a lot more to improving your toolbox than just using another language. IDEs and other editors are all apart of this. While I am in favor of the language I first learned and the editor I first used I can see that there are tons and tons of choices to be made in picking these things and the more familiar you are with these different editors the better off you are when something new is introduced to you. It is important to keep learning new ways of writing and working with code because it allows you to become a more versitile programmer in the long run. 
      <p>
        <br>
   <h2>12 Factor App</h2>
    <p> Codebase or repos are essiential for tracking code changes and allowing developers to access the code and work on it. They allow code access on multiple machines. Programs or apps shoe come packaged with any extra software, files, libraries etc to satisfy the 12 factor. You can not assume that every machine that will use the app will have the prerequisites installed. Configs are important parts of programs and its bad practice to group these. It is better to hanle them indepently as they allow for easier scale up. Any third party services should be considered attached resources to the protject. Access information for any service whether it is third party or not should be stored in the config. Build, release, and run stages are kept seperate and no modifications are made in the run stage. Release tracking is a good thing and each release should have a unique ID. 
      <p>
        <br>
        <h2> The Mythical Man-Month </h2>
          <p> I found this reading to be very interesting. Firstly I have never been formally introduced to the idea of a man-month. Having now read about it I understand it and see how it can be a useful tool for estimating the length of a progect and how much time it will take. I also think this reading brings up a really good point, this is a pretty bad tool for estimating software developement time. I agree with the idea that we are all extra optimistic at a start of a project. I myself start optimistic because I first think of the big ideas and I think to myself, yeah thats not to challenging or I've done something similar to this before, but when I start to think more about the different tasks and plan them more I realize that its not all as simple as I originally made it out to be and suddenly it takes twice as long to implement, not to mention the testing part. <p>
  
          <p> I also found it interesting that this reading compared software engineering to other types of engineering. While I realize they use the same terminology I have still considered them vastly different from each other and not really think of together at all. These differences are shown in the idea of the man month not being applicable to software engineering when other types might be able to use it pretty readily. <p>
          <br>
    <h2> Chapter 4 Pragmatic Paranoia </h2>
      <p> It is a sad realization that no software is perfect. Even with the projects I've done I am constrantly finding ways to improve it or am selfdriven to try and make it better. iContract sounds like a programming language that makes use of the "@" notations to mark up pre/post conditions and invariances. The idea of invariances is interesting because it allows you to return an unaltered input that can then be passed onto another method or be made into a global variable for the rest of the prgram to use. I am confused by the exception section, in my experience when you call the new file command you are creating a file, would than then make the if.exists check irrelavent because the file will always be made? I can understand using the if.exists if the file name is passed in, but they create the file then check to see if it exists.
      <p>
        <br>
  <h2> Chapter 5 Bend or Break </h2>
    <p> The first part of this chapter talks about writing methods that arn't coupled to other methods. One way to fix this problem is to change what information gets passed into the method and how the information is handled. They talk about not making code where you frequently are in the situation where changing one method then causes you to change many more methods as the change trickles down through the program. I thought is was good practice to write smaller methods and to call them in other methods instead of having one method that has many many lines of code and becomes difficult to read. I feel like these two ideas contradict. I guess this can work out as long as the information provided by the methods doesnt change. The way it gets the info doesnt matter just as long as it returns it. <p>
  <br>
  
  <h2> Chapter 6  </h2>
</body>
</html>

